<#
.SYNOPSIS
    Pull Qualys failed postures, optionally run perâ€‘CID fixers (parallel supported), and report.
    Optionally trigger a Qualys rescan after successful fixes.

.DESCRIPTION
    - Downloads plain CSV of failed postures (status=Failed) for one policy from Qualys.
    - Trims any preamble until the true CSV header which starts with the quoted columns:
        "ID","IP","OS","DNS Name" (additional columns may follow).
    - Uses the fixed CSV schema fields we care about:
        IP, DNS Name, Control ID, Posture Evidence, Reason for Failure
    - Groups by target (IP preferred, else DNS Name) and Control ID (CID).
    - If -Remediate, runs C:\temp\scripts\fixers\<CID>-*.ps1 via PowerShell Remoting.
      If -Parallel, executes fixers concurrently with -ThrottleLimit.
    - If -Rescan, launches a Qualys compliance rescan for hosts with successful fixes (needs IP).
    - Writes C:\temp\scripts\reports\FailedCompliance_<timestamp>.csv

.PARAMETER QualysBaseUrl
    Qualys API base URL (e.g. https://qualysapi.qualys.eu).

.PARAMETER QualysCredential
    PSCredential for Qualys API.

.PARAMETER PolicyId
    Qualys policy ID (default 99999).

.PARAMETER TruncationLimit
    Max records (default 10000; set 0 to omit).

.PARAMETER AdminCredential
    Credential for PowerShell Remoting to targets (required with -Remediate).

.PARAMETER Remediate
    Run fixers for each target/CID if a matching fixer script exists.

.PARAMETER Parallel
    Process fixers in parallel using ForEach-Object -Parallel (PowerShell 7+).

.PARAMETER ThrottleLimit
    Maximum concurrent fixer executions when -Parallel is used (default 8).

.PARAMETER Rescan
    After a successful fix and when an IP is available, launch a Qualys compliance rescan.

.NOTES
    PowerShell 7.5.2. Working dir: C:\temp\scripts
    Logs:   C:\temp\scripts\logs\CheckAndRemediate_<yyyyMMdd_HHmm>.log
    Report: C:\temp\scripts\reports\FailedCompliance_<yyyyMMdd_HHmm>.csv

    Signed by Marinus van Deventer
#>

[CmdletBinding(DefaultParameterSetName='Report')]
param(
    [Parameter(Mandatory=$true)][ValidateNotNullOrEmpty()][string]$QualysBaseUrl,
    [Parameter(Mandatory=$true)][System.Management.Automation.PSCredential]$QualysCredential,
    [int]$PolicyId = 99999,
    [int]$TruncationLimit = 10000,

    [Parameter(Mandatory=$true, ParameterSetName='Remediate')]
    [System.Management.Automation.PSCredential]$AdminCredential,

    [Parameter(ParameterSetName='Remediate')]
    [switch]$Remediate,

    [Parameter(ParameterSetName='Remediate')]
    [switch]$Parallel,

    [Parameter(ParameterSetName='Remediate')]
    [ValidateRange(1,128)][int]$ThrottleLimit = 8,

    [Parameter(ParameterSetName='Remediate')]
    [switch]$Rescan
)

begin {
    $ErrorActionPreference = 'Stop'
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

    $workingDir  = 'C:\temp\scripts'
    $logsDir     = Join-Path $workingDir 'logs'
    $reportsDir  = Join-Path $workingDir 'reports'
    $fixersDir   = Join-Path $workingDir 'fixers'
    foreach ($d in @($workingDir,$logsDir,$reportsDir,$fixersDir)) {
        if (-not (Test-Path $d -PathType Container)) { New-Item -Path $d -ItemType Directory -Force | Out-Null }
    }

    $stamp      = Get-Date -Format 'yyyyMMdd_HHmm'
    $logPath    = Join-Path $logsDir    "CheckAndRemediate_$stamp.log"
    $reportPath = Join-Path $reportsDir "FailedCompliance_$stamp.csv"
    $csvPath    = Join-Path $workingDir 'Qualys_Posture.csv'  # use .txt if you prefer; logic is the same

    if (-not (Test-Path $logPath)) { New-Item -ItemType File -Path $logPath -Force | Out-Null }

    function Write-Log {
        param([string]$Message,[ValidateSet('INFO','WARNING','ERROR')][string]$Level='INFO')
        $ts = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        $line = "[$ts] [$Level] $Message"
        Write-Information $line -InformationAction Continue
        Add-Content -Path $logPath -Value $line -Encoding UTF8
    }

    # NEW: robust preamble trimmer for QUOTED header lines, prefix match, case-insensitive
    function Remove-CsvPreamble {
        param(
            [Parameter(Mandatory=$true)][string]$FilePath,
            [Parameter(Mandatory=$true)][string[]]$HeaderColumns,
            [char]$Delimiter = ','
        )
        if (-not (Test-Path $FilePath)) { Write-Log "File not found: $FilePath" 'ERROR'; throw "File not found: $FilePath" }

        # Build a quoted, comma-separated prefix like: "ID","IP","OS","DNS Name"
        $quotedPrefix = '"' + ($HeaderColumns -join '","') + '"'

        # Read as raw text and split lines robustly (handles CRLF, LF)
        $text  = Get-Content -Path $FilePath -Raw -Encoding UTF8
        if ([string]::IsNullOrWhiteSpace($text)) { throw "Empty CSV body." }
        $lines = $text -split "(`r`n|`n|`r)"

        # Find the first line that starts with the quoted prefix (case-insensitive)
        $idx = -1
        for ($i=0; $i -lt $lines.Count; $i++) {
            $line = $lines[$i].TrimStart()  # tolerate leading BOM/whitespace
            if ($line.StartsWith($quotedPrefix, $true, [Globalization.CultureInfo]::InvariantCulture)) { $idx = $i; break }
        }

        if ($idx -lt 0) {
            Write-Log "Header not found. Expected prefix: $quotedPrefix" 'ERROR'
            throw "Header row not found (quoted prefix search failed)."
        }

        if ($idx -gt 0) {
            $newText = ($lines[$idx..($lines.Count-1)] -join [Environment]::NewLine)
            Set-Content -Path $FilePath -Value $newText -Encoding UTF8
            Write-Log "Trimmed $($idx) preamble lines in $FilePath"
        } else {
            Write-Log "Header already on first line in $FilePath"
        }
    }

    function Invoke-QualysCsv {
        param([string]$BaseUrl,[pscredential]$Cred,[int]$Policy,[int]$Limit,[string]$OutCsv)
        $pair = '{0}:{1}' -f $Cred.UserName, $Cred.GetNetworkCredential().Password
        $auth = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($pair))
        $headers = @{ Authorization = "Basic $auth"; Accept = 'text/csv'; 'X-Requested-With'='PowerShell' }

        $body = @{
            action        = 'list'
            policy_id     = $Policy
            output_format = 'csv'     # plain CSV
            status        = 'Failed'
            details       = 'All'
        }
        if ($Limit -gt 0) { $body.truncation_limit = $Limit }

        $uri = ($BaseUrl.TrimEnd('/')) + '/api/2.0/fo/compliance/posture/info/'
        Invoke-RestMethod -Uri $uri -Headers $headers -Method Post -ContentType 'application/x-www-form-urlencoded' -Body $body -OutFile $OutCsv

        # IMPORTANT: your CSV/TXT header is quoted; match the quoted prefix
        Remove-CsvPreamble -FilePath $OutCsv -HeaderColumns @('ID','IP','OS','DNS Name')
    }

    function Get-QualysFailures {
        param([string]$BaseUrl,[pscredential]$Cred,[int]$Policy,[int]$Limit,[string]$OutCsv)
        Invoke-QualysCsv -BaseUrl $BaseUrl -Cred $Cred -Policy $Policy -Limit $Limit -OutCsv $OutCsv

        $raw = Import-Csv -Path $OutCsv
        if (-not $raw -or $raw.Count -eq 0) { return @() }

        # Fixed schema projection (no guessing)
        $rows = $raw | ForEach-Object {
            [pscustomobject]@{
                TargetName = if ($_.IP) { $_.IP } else { $_.'DNS Name' }
                IP         = $_.IP
                Hostname   = $_.'DNS Name'
                CID        = $_.'Control ID'
                Evidence   = $_.'Posture Evidence'
                Reason     = $_.'Reason for Failure'
            }
        } | Where-Object { $_.TargetName -and ($_.CID -match '^\d+$') }

        return $rows
    }

    function Find-Fixer {
        param([int]$CID)
        $match = Get-ChildItem -Path $fixersDir -Filter "$CID-*.ps1" -File | Select-Object -First 1
        if ($null -eq $match) { return $null }
        return $match.FullName
    }

    function Run-Fixer {
        param([string]$Computer,[pscredential]$Cred,[string]$FixerPath)
        try {
            $scriptText = Get-Content -Path $FixerPath -Raw
            $sb = [scriptblock]::Create($scriptText)
            $ret = Invoke-Command -ComputerName $Computer -Credential $Cred -ScriptBlock $sb -ErrorAction Stop
            $outcome = if ($ret -and $ret.PSObject.Properties.Name -contains 'Outcome') { [string]$ret.Outcome } else { 'Succeeded' }
            $details = if ($ret -and $ret.PSObject.Properties.Name -contains 'Details') { [string]$ret.Details } else { '' }
            return @('Yes', $outcome, $details)
        } catch {
            return @('Yes', 'Failed', $_.Exception.Message)
        }
    }

    function Invoke-QualysRescan {
        param([string]$BaseUrl,[pscredential]$Cred,[string]$HostIP)
        if (-not $HostIP) { return $false }
        try {
            $pair = '{0}:{1}' -f $Cred.UserName, $Cred.GetNetworkCredential().Password
            $auth = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($pair))
            $headers = @{ Authorization = "Basic $auth"; Accept = 'application/xml'; 'X-Requested-With'='PowerShell' }
            $body = @{
                action     = 'launch'
                scan_title = "AutoRescan_$($HostIP)_$([DateTime]::UtcNow.ToString('yyyyMMdd_HHmmss'))"
                ip         = $HostIP
                priority   = 'Normal'
            }
            $uri = ($BaseUrl.TrimEnd('/')) + '/api/2.0/fo/scan/compliance/'
            Invoke-RestMethod -Uri $uri -Headers $headers -Method Post -ContentType 'application/x-www-form-urlencoded' -Body $body | Out-Null
            Write-Log "Rescan requested for $($HostIP)"
            return $true
        } catch {
            Write-Log "Rescan request failed for $($HostIP): $($_.Exception.Message)" 'WARNING'
            return $false
        }
    }

    Write-Log "Initialised. PolicyId=$PolicyId Remediate=$Remediate Parallel=$Parallel Throttle=$ThrottleLimit Rescan=$Rescan"
}

process {
    try {
        # 1) Pull failures
        Write-Log "Downloading Qualys failures..."
        $failures = Get-QualysFailures -BaseUrl $QualysBaseUrl -Cred $QualysCredential -Policy $PolicyId -Limit $TruncationLimit -OutCsv $csvPath
        Write-Log "Retrieved $($failures.Count) actionable failures."

        if ($failures.Count -eq 0) {
            @() | Select-Object TargetName,IP,Hostname,CID,Evidence,Reason,FixAttempted,Outcome,Details | Export-Csv -Path $reportPath -NoTypeInformation -Encoding UTF8
            Write-Log "Report generated: $($reportPath)"
            return
        }

        # 2) Group by Target and CID
        $work = $failures | Group-Object TargetName | ForEach-Object {
            $t = $_.Name
            $_.Group | Group-Object CID | ForEach-Object {
                [pscustomobject]@{
                    TargetName = $t
                    CID        = [int]$_.Name
                    IP         = ($_.Group | ForEach-Object IP       | Where-Object { $_ } | Select-Object -First 1)
                    Hostname   = ($_.Group | ForEach-Object Hostname | Where-Object { $_ } | Select-Object -First 1)
                    Evidence   = ($_.Group | ForEach-Object Evidence | Where-Object { $_ } | Select-Object -Unique) -join '; '
                    Reason     = ($_.Group | ForEach-Object Reason   | Where-Object { $_ } | Select-Object -Unique) -join '; '
                }
            }
        }

        # 3) Remediate (optionally parallel) and collect results
        $results = New-Object System.Collections.Concurrent.ConcurrentBag[object]

        if ($Remediate -and $Parallel) {
            $work | ForEach-Object -Parallel {
                param($item)

                $AdminCredential = $using:AdminCredential
                $Rescan          = $using:Rescan
                $QualysBaseUrl   = $using:QualysBaseUrl
                $QualysCredential= $using:QualysCredential

                function Find-FixerInner {
                    param([int]$CID)
                    $fixersDir = 'C:\temp\scripts\fixers'
                    $match = Get-ChildItem -Path $fixersDir -Filter "$CID-*.ps1" -File | Select-Object -First 1
                    if ($null -eq $match) { return $null }
                    return $match.FullName
                }
                function Run-FixerInner {
                    param([string]$Computer,[pscredential]$Cred,[string]$FixerPath)
                    try {
                        $scriptText = Get-Content -Path $FixerPath -Raw
                        $sb = [scriptblock]::Create($scriptText)
                        $ret = Invoke-Command -ComputerName $Computer -Credential $Cred -ScriptBlock $sb -ErrorAction Stop
                        $outcome = if ($ret -and $ret.PSObject.Properties.Name -contains 'Outcome') { [string]$ret.Outcome } else { 'Succeeded' }
                        $details = if ($ret -and $ret.PSObject.Properties.Name -contains 'Details') { [string]$ret.Details } else { '' }
                        return @('Yes', $outcome, $details)
                    } catch {
                        return @('Yes', 'Failed', $_.Exception.Message)
                    }
                }
                function Invoke-QualysRescanInner {
                    param([string]$BaseUrl,[pscredential]$Cred,[string]$HostIP)
                    if (-not $HostIP) { return $false }
                    try {
                        $pair = '{0}:{1}' -f $Cred.UserName, $Cred.GetNetworkCredential().Password
                        $auth = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($pair))
                        $headers = @{ Authorization = "Basic $auth"; Accept = 'application/xml'; 'X-Requested-With'='PowerShell' }
                        $body = @{ action='launch'; scan_title="AutoRescan_$($HostIP)_$([DateTime]::UtcNow.ToString('yyyyMMdd_HHmmss'))"; ip=$HostIP; priority='Normal' }
                        $uri = ($BaseUrl.TrimEnd('/')) + '/api/2.0/fo/scan/compliance/'
                        Invoke-RestMethod -Uri $uri -Headers $headers -Method Post -ContentType 'application/x-www-form-urlencoded' -Body $body | Out-Null
                        return $true
                    } catch { return $false }
                }

                $fixAttempted = 'No'; $outcome = 'Not Attempted'; $details = ''
                $fixer = Find-FixerInner -CID $item.CID
                if ($fixer) {
                    $vals = Run-FixerInner -Computer $item.TargetName -Cred $AdminCredential -FixerPath $fixer
                    $fixAttempted = $vals[0]; $outcome = $vals[1]; $details = $vals[2]
                    if ($Rescan -and $outcome -match '^(Succeeded|Success|Fixed)$' -and $item.IP) {
                        [void](Invoke-QualysRescanInner -BaseUrl $QualysBaseUrl -Cred $QualysCredential -HostIP $item.IP)
                    }
                } else {
                    $outcome = 'No Fixer Available'
                }

                $obj = [pscustomobject]@{
                    TargetName   = $item.TargetName
                    IP           = $item.IP
                    Hostname     = $item.Hostname
                    CID          = $item.CID
                    Evidence     = $item.Evidence
                    Reason       = $item.Reason
                    FixAttempted = $fixAttempted
                    Outcome      = $outcome
                    Details      = $details
                }
                $using:results.Add($obj)
            } -ThrottleLimit $ThrottleLimit
        } else {
            foreach ($item in $work) {
                $fixAttempted = 'No'; $outcome = 'Not Attempted'; $details = ''
                if ($Remediate) {
                    $fixer = Find-Fixer -CID $item.CID
                    if ($null -eq $fixer) {
                        $outcome = 'No Fixer Available'
                    } else {
                        $vals = Run-Fixer -Computer $item.TargetName -Cred $AdminCredential -FixerPath $fixer
                        $fixAttempted = $vals[0]; $outcome = $vals[1]; $details = $vals[2]
                        if ($Rescan -and $outcome -match '^(Succeeded|Success|Fixed)$' -and $item.IP) {
                            [void](Invoke-QualysRescan -BaseUrl $QualysBaseUrl -Cred $QualysCredential -HostIP $item.IP)
                        }
                    }
                }
                $results.Add([pscustomobject]@{
                    TargetName   = $item.TargetName
                    IP           = $item.IP
                    Hostname     = $item.Hostname
                    CID          = $item.CID
                    Evidence     = $item.Evidence
                    Reason       = $item.Reason
                    FixAttempted = $fixAttempted
                    Outcome      = $outcome
                    Details      = $details
                })
            }
        }

        # 4) Report
        $results.ToArray() | Export-Csv -Path $reportPath -NoTypeInformation -Encoding UTF8
        Write-Log "Report generated: $($reportPath)"
    } catch {
        Write-Log "Failure in process: $($_.Exception.Message)" 'ERROR'
        throw
    }
}

end {
    if (Test-Path $csvPath) { Remove-Item $csvPath -Force }
    Write-Log 'Completed.'
}

# Signed by Marinus van Deventer